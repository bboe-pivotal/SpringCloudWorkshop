:compat-mode:
= Lab 5 - Build a Hypermedia-Driven RESTful Web Service with Spring Data REST

In this lab we'll utilize Spring Boot, Spring Data, and Spring Data REST to create a fully-functional hypermedia-driven RESTful web service. We'll then deploy it to Cloud Foundry (using Pivotal Web Services).

NOTE: The completed code for this lab can be found at `$COURSE_HOME/session_03/lab_05/complete/cities`.

== Initializing the Application

. Change to the lab directory:
+
----
$ cd $COURSE_HOME/session_03/lab_05/initial/cities
----

. Throughout the rest of today's labs, we'll often be writing code.  You can always edit source code files directly in your favorite text editor, but in the real world, you'd want to import these projects into a real development environment like Eclipse/RAD or IntelliJ.  Fortunately, its easy to do this.  You can generate project files for your favorite IDE by running going to the root project directory and running +gradlew.bat eclipse+ or +gradlew.bat idea+. When this command is completed, you can use the import existing project function of your editor, point it at the same directory you ran the gradle command in, and bring in all of the necessary files to edit within the IDE.
+
So, for the next steps, you can either use a text editor or IDE.
. Add a runtime dependency on the http://hsqldb.org/[HyperSQL in-memory database] to +build.gradle+:
+
[source,groovy]
----
buildscript {
...
  dependencies {
    //NOT HERE
  }
}
...
dependencies {
    compile("org.springframework.boot:spring-boot-starter-data-jpa")
    compile("org.springframework.boot:spring-boot-starter-web")
    compile("org.springframework.boot:spring-boot-starter-data-rest")
    compile("org.springframework.boot:spring-boot-starter-actuator")
    testCompile("org.springframework.boot:spring-boot-starter-test")
    runtime("org.hsqldb:hsqldb") // <-- Add this line
}
----

. Create the package +org.example.cities.domain+ and in that package create the class +City+. Into that file you can paste the following source code, which represents cities based on postal codes, global coordinates, etc:
+
[source,java]
----
package org.example.cities.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name="city")
public class City implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue
    private long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String county;

    @Column(nullable = false)
    private String stateCode;

    @Column(nullable = false)
    private String postalCode;

    @Column
    private String latitude;

    @Column
    private String longitude;

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getPostalCode() { return postalCode; }

    public void setPostalCode(String postalCode) { this.postalCode = postalCode; }

    public long getId() { return id; }

    public void setId(long id) { this.id = id; }

    public String getStateCode() { return stateCode; }

    public void setStateCode(String stateCode) { this.stateCode = stateCode; }

    public String getCounty() { return county; }

    public void setCounty(String county) { this.county = county; }

    public String getLatitude() { return latitude; }

    public void setLatitude(String latitude) { this.latitude = latitude; }

    public String getLongitude() { return longitude; }

    public void setLongitude(String longitude) { this.longitude = longitude; }
}
----
+
Notice that we're using JPA annotations on the class and its fields.

. Create the package +org.example.cities.repositories+ and in that package create the interface +CityRepository+. Paste the following code and add appropriate imports:
+
[source,java]
----
package org.example.cities.repositories;

import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;
import org.example.cities.domain.City;

@RepositoryRestResource(collectionResourceRel = "cities", path = "cities")
public interface CityRepository extends PagingAndSortingRepository<City, Long> {
}
----

. Add JPA and REST Repository support to the +org.example.cities.CitiesApplication+ class that was generated by Spring Initializr.
+
[source,java]
----
package org.example.cities;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Import; // <--- Add this
import org.springframework.data.jpa.repository.config.EnableJpaRepositories; // <--- Add this
import org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration; // <--- Add this

@SpringBootApplication
@EnableJpaRepositories // <---- Add this
@Import(RepositoryRestMvcConfiguration.class) // <---- And this
public class CitiesApplication {

    public static void main(String[] args) {
        SpringApplication.run(CitiesApplication.class, args);
    }
}
----

. Build the application:
+
[source,bash]
----
$ gradlew.bat assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application using +Firefox+ (Note that for the lab on 2/23, the proxy settings on Internet Explorer prevent accessing localhost, so you must use Firefox). You'll see that the primary endpoint automatically exposes the ability to page, size, and sort the response JSON.
+
So what have you done? Created four small classes and one build file, resulting in a fully-functional REST microservice. The application's +DataSource+ is created automatically by Spring Boot using the in-memory database because no other +DataSource+ was detected in the project.
+
Note: By default Firefox will prompt you to download responses.  Its much nicer to view responses directly in the browser.  To do so, search for and add the JSONView plugin to firefox.  Then, got to the extensions page (`ctrl+alt+a`), find the JSONView extension and go to options.  There you can add _Alternate JSON content types_ that should be opened by the extension.  Add `application/hal+json` to this list.  After that, instead of prompting to download, Firefox will display json directly in the browser.
+
[source,bash]
----
http://localhost:8080/cities

{
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },
  "page" : {
    "size" : 20,
    "totalElements" : 0,
    "totalPages" : 0,
    "number" : 0
  }
}
----
+
Next we'll import some data.

== Importing Data

. Add this link:import.sql[import.sql file], which can also be found at $COURSE_HOME/session_03/lab_05/import.sql, to  +src/main/resources+. This file contains a subset of all postal codes in the United States and its territories. This file will automatically be picked up by Hibernate and imported into the in-memory database.

. Build the application:
+
[source,bash]
----
$ gradlew.bat assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application again using +firefox+. Notice the appropriate hypermedia is included for +next+, +previous+, and +self+. You can also select pages and page size by utilizing +?size=n&page=n+ on the URL string. Finally, you can sort the data utilizing +?sort=fieldName+.
+
[source,bash]
----
localhost:8080/cities

{
  "_links" : {
    "next" : {
      "href" : "http://localhost:8080/cities?page=1&size=20"
    },
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },
  "_embedded" : {
    "cities" : [ {
      "name" : "HOLTSVILLE",
      "county" : "SUFFOLK",
      "stateCode" : "NY",
      "postalCode" : "00501",
      "latitude" : "+40.922326",
      "longitude" : "-072.637078",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/cities/1"
        }
      }
    },

    // ...

    {
      "name" : "CASTANER",
      "county" : "LARES",
      "stateCode" : "PR",
      "postalCode" : "00631",
      "latitude" : "+18.269187",
      "longitude" : "-066.864993",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/cities/20"
        }
      }
    } ]
  },
  "page" : {
    "size" : 20,
    "totalElements" : 1000,
    "totalPages" : 50,
    "number" : 0
  }
}
----

. Try the following urls  to see how the application behaves:
+
[source,bash]
----
localhost:8080/cities?size=5
localhost:8080/cities?size=5&page=3
localhost:8080/cities?sort=postalCode,desc
----
+
Next we'll add searching capabilities.

== Adding Search

. Let's add some additional finder methods to +CityRepository+:
+
[source,java]
----
@RestResource(path = "name", rel = "name")
Page<City> findByNameIgnoreCase(@Param("q") String name, Pageable pageable);

@RestResource(path = "nameContains", rel = "nameContains")
Page<City> findByNameContainsIgnoreCase(@Param("q") String name, Pageable pageable);

@RestResource(path = "state", rel = "state")
Page<City> findByStateCodeIgnoreCase(@Param("q") String stateCode, Pageable pageable);

@RestResource(path = "postalCode", rel = "postalCode")
Page<City> findByPostalCode(@Param("q") String postalCode, Pageable pageable);
----
. Also, add these imports:
+
[source,java]
----
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.query.Param;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;
import org.springframework.data.rest.core.annotation.RestResource;
----

. Build the application:
+
[source,bash]
----
$ gradlew.bat assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application again from Firefox. Notice that hypermedia for a new +search+ endpoint has appeared.
+
[source,bash]
----
localhost:8080/cities

{
  "_links" : {
    "next" : {
      "href" : "http://localhost:8080/cities?page=1&size=20"
    },
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    },
    "search" : {
      "href" : "http://localhost:8080/cities/search"
    }
},
// (Remainder omitted...)
----

. Access the new +search+ endpoint using +curl+:
+
[source,bash]
----
localhost:8080/cities/search

{
  "_links" : {
    "postalCode" : {
      "href" : "http://localhost:8080/cities/search/postalCode{?q,page,size,sort}",
      "templated" : true
    },
    "state" : {
      "href" : "http://localhost:8080/cities/search/state{?q,page,size,sort}",
      "templated" : true
    },
    "name" : {
      "href" : "http://localhost:8080/cities/search/name{?q,page,size,sort}",
      "templated" : true
    },
    "nameContains" : {
      "href" : "http://localhost:8080/cities/search/nameContains{?q,page,size,sort}",
      "templated" : true
    }
  }
}
----
+
Note that we now have new search endpoints for each of the finders that we added.

. Try a few of these endpoints. Feel free to substitute your own values for the parameters.
+
[source,bash]
----
http://localhost:8080/cities/search/postalCode?q=00623
http://localhost:8080/cities/search/name?q=Boston
http://localhost:8080/cities/search/nameContains?q=Fort&size=1
----

== Pushing to Cloud Foundry

. Create an application manifest in +manifest.yml+:
+
[source,yml]
----
---
applications:
- name: cities
  host: cities-${random-word}
  memory: 512M
  instances: 1
  path: build/libs/cities-0.0.1-SNAPSHOT.jar
  timeout: 180 # to give time for the data to import
----

. Push to Cloud Foundry:
+
[source,bash]
----
$ cf push

...

1 of 1 instances running

App started

Showing health and status for app cities...
OK

requested state: started
instances: 1/1
usage: 512M x 1 instances
urls: cities-undeliverable-iatrochemistry.cf.mycloud.com

     state     since                    cpu    memory         disk
#0   running   2014-05-27 04:15:05 PM   0.0%   433M of 512M   128.9M of 1G
----

. Access the application at the random route provided by CF:
+
[source,bash]
----
cities-undeliverable-iatrochemistry.cf.mycloud.com/cities
----

link:/README.md#course-materials[Course Materials home] | link:/session_02_b/lab_05/lab_05.adoc[Spring Boot - From Zero to Microservice in Five Minutes]  | link:/session_03/lab_06/lab_06.adoc[Lab 6 - Leveraging Spring Cloud Connectors for Service Binding]
